<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: AVTP Interface Module Development</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Table&#160;of&#160;Contents</span></a></li>
      <li class="current"><a href="pages.html"><span>Topics</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AVTP Interface Module Development </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sdk_avtp_intf_module_introduction"></a>
Introduction </h1>
<p>Interface modules are the components that sit between the core AVB stack and the platform device drivers that supply access to media hardware.</p>
<p><br />
</p>
<h1><a class="anchor" id="sdk_avtp_intf_module_plugin"></a>
The Plug-in Architecture </h1>
<p>The OPENAVB AVB stack has a plug-in architecture for the AVTP implementation in the form of interface modules. This allows for easily hooking into the AVB stack to extend it for interfacing to media specific hardware.</p>
<p>Mapping modules, which are mentioned through-out these guides, are also plug-ins. These implement the various AVTP encapsulations and require a deep understanding of AVTP and therefore are developed internally by OPENAVB.</p>
<p>Interface modules are discovered at runtime using configuration information that is passed to the openavbTLOpen() function. Below is an example of a section of the configuration information with interface module values.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// pIntfInitFn : Interface module initialization function.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// openavb_intf_initialize_fn_t)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cfg-&gt;osalCfg.pIntfInitFn = openavbIntfJ6Video;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;///////////////////</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// Interface module</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;///////////////////</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;// intf_nv_blocking_tx_callback : A talker only option. When set packet pacing</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// is expected to be handled in the interface module.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// Commonly the TL configuration option tx_blocking_in_intf needs to be set</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// to match this.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// cfg-&gt;libCfgNames[cfgIdx] = &quot;intf_nv_blocking_tx_callback&quot;;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// cfg-&gt;libCfgValues[cfgIdx++] = &quot;1&quot;;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;// intf_nv_ignore_timestamp : If set the listener will ignore the timestamp</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;// on media queue items.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;cfg-&gt;libCfgNames[cfgIdx] = &quot;intf_nv_ignore_timestamp&quot;;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;cfg-&gt;libCfgValues[cfgIdx++] = &quot;0&quot;;</div></div><!-- fragment --><p>The function pointer variable <code>pIntfInitFn</code> points to the interface module initialization function.</p>
<p>When the talker/listener module calls the interface module initialization function it passes in a callback structure as a parameter that must get filled with the required callback function addresses by the interface module.</p>
<p>After initialization the talker/listener module will call directly into the interface module via these callbacks. See the API reference section for details and examples of these callbacks.</p>
<p>The callback functions in an interface module, aside from the initialization call, receives a pointer to a media queue structure. This structure is self-contained, similar to an object in C++, in that it includes a function callback list for the interface module to call into the media queue to access and work with the media queue.</p>
<p><br />
</p>
<h1><a class="anchor" id="sdk_avtp_intf_module_task"></a>
Task / Thread Model </h1>
<p>In the general case the task / threading (hereafter referred to as task) model for interface modules is very simple. All callbacks will occur on the same task and therefore there are no synchronization concerns. However, access to media sources and media sinks can have demanding timing and processing requirements and it may be necessary for an interface module to have complete control over an execution task to ensure timely pulling or pushing data into the media hardware or driver. In those cases the interface module may find it a benefit to create its own task or tasks.</p>
<p>When an interface module has its own task the point of synchronization between the callback thread and the interface module private thread would be the sharing of a media queue item pointer. When a head or tail item is locked a pointer to that media queue item is returned. At that point the data area for that item remains locked and can be used by another task beyond the scope of the callback into the interface module. The media queue item will remain locked until unlocked (or pushed or pulled). The media queue itself can't be locked, it can only be accessed within the scope of a callback into the interface module.</p>
<p><br />
</p>
<h1><a class="anchor" id="sdk_avtp_intf_module_building"></a>
Building an Interface Module </h1>
<p>There should be minimal dependencies for creation of an interface module. The interface module can be built as a static library and include all the required callbacks as defined in the reference section of this document.</p>
<p>Access to all functionality in the AVB stack from an interface module is also handled via callbacks that are available to the interface module in the media queue structure it receives as a parameter on its own callbacks.</p>
<p><br />
</p>
<h1><a class="anchor" id="sdk_avtp_intf_module_talker"></a>
Interface Module in a Talker </h1>
<p>An interface module when used in a talker pulls data from a media source and pushes it onto the media queue in the format expected by the mapping module configured for that stream.</p>
<p><br />
</p>
<h1><a class="anchor" id="sdk_avtp_intf_module_listener"></a>
Interface Module in a Listener </h1>
<p>When called from a listener it pulls data from the media queue and pushes it to the media sink for presentation.</p>
<p><br />
</p>
<h1><a class="anchor" id="working_with_mediaq"></a>
Working With the Media Queue </h1>
<p>The media queue is the conduit between interface modules and mapping modules. The media queue is the only entry point for interface modules to call into the AVB stack and allows for pushing or pulling media data though it as well as access to time functionality in the AVTP time structure.</p>
<p>The media queue is internally implemented as a circular FIFO container. The format of the data for items in the media queue is defined by the mapping module being used in the talker/listener. For some mapping modules the data format of an item will match the defined AVB encapsulation. For example the MPEG2-TS (61883-4) mapping module data format of media queue items are simple 192 byte MPEG2-TS source packets. Each media queue item contains one or more MPEG2-TS source packet. The actual MPEG2-TS mapping may combine multiple source packets into one AVTP packet but that is hidden from the interface module.</p>
<p>The media queue functions are accessed as API calls.</p>
<p>For example, the openavbMediaQHeadLock() function is called as: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;openavbMediaQHeadLock(pMediaQ);</div></div><!-- fragment --><p> The pMediaQ pointer is passed to all of the interface module callbacks.</p>
<p>Access to the queue items is accomplished with the Head functions for pushing data into the media queue. These are used by interface modules running in a talker. To read items from the media queue the Tail functions are used by interface modules running in a listener.</p>
<p>At any one time only 2 items are accessible in the media queue. These are the head item and tail item. Care must be taken to always match up the openavbMediaQHeadLock() with a openavbMediaQHeadUnlock() or openavbMediaQHeadPush() functions. The same applies that the openavbMediaQTailLock() must be paired with either a openavbMediaQTailPull() or openavbMediaQTailUnlock() functions. This means a new item can not be added to the media queue until a openavbMediaQHeadPush() is called and a new item can not be pulled from the media queue until openavbMediaQTailPull() is called.</p>
<p>For a detailed work flow please visit <a class="el" href="sdk_notes_media_queue_usage.html">Media Queue Usage</a></p>
<p><br />
</p>
<h1><a class="anchor" id="sdk_avtp_intf_module_timestamps"></a>
Timestamps </h1>
<p>For interface modules often the only requirement for timestamps is to assign a PTP time to the items added to the media queue when running as a talker. For example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;openavbAvtpTimeSetToWallTime(pMediaQItem-&gt;pAvtpTime);</div></div><!-- fragment --><p> In most cases the mapping modules and media queue take care of the rest of the requirements for AVTP.</p>
<p>Source code </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
