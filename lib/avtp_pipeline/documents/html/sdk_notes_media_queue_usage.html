<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Media Queue Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Table&#160;of&#160;Contents</span></a></li>
      <li class="current"><a href="pages.html"><span>Topics</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Media Queue Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Description</h1>
<p>This section presents the work flow required for working with the Media Queue. Please note that most of the described steps are performed inside the AVB stack and are hidden from interface module implemented. There are also some simplifications to make description as straightforward as possible.</p>
<p><br />
</p>
<h1>Workflow</h1>
<p>The following work flow steps will be described.</p><ul>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_start">Starting</a> - Initialization common for talker and listener streams</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_talker">Talker specific</a> - Talker specific usage</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_listener">Listener specific</a> - Listener specific usage</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_stop">Stopping</a> - Stopping procedure common for talker and listener streams</li>
<li><a class="el" href="sdk_notes_media_queue_usage.html#media_queue_usage_rules">Rules</a> - general rules to follow while using the Media Queue</li>
</ul>
<p><br />
</p>
<h1><a class="anchor" id="media_queue_usage_start"></a>
Starting </h1>
<p>First the Media Queue has to be created and initialized with correct data. Below are the function calls needed for proper creation and initialization. Note: these calls are initiated from the AVTP module.</p>
<ul>
<li>openavbMediaQCreate - data is allocated, queue is initialized, internal data structures are prepared</li>
<li>openavbMediaQSetMaxStaleTail - sets maximum stale in microseconds before data is being purged</li>
<li>The Interface module initialization function for this media queue is called with media queue as a parameter, those functions<ul>
<li>Set internal interface module parameters</li>
<li>Initialize Media Queue<ul>
<li>Creates Media Queue Interface Module Private Data</li>
<li>Fills the private data structure with information needed by interface module</li>
</ul>
</li>
</ul>
</li>
<li>Stream configuration values are processed. This actually configuration data may come from .ini files or internally set within the AVB host application.</li>
<li>Mapping module init function openavb_map_cb_t::map_gen_init_cb is being called during which several steps (media queue parameters <b>have to</b> be set)<ul>
<li>Media Queue Items count is set</li>
<li>Media Queue Items are allocated</li>
</ul>
</li>
<li>Interface module init function openavb_intf_cb_t::intf_gen_init_cb function is called</li>
</ul>
<p>Now the listener/talker stream is running. See next steps below for details of Media Queue interaction for the talker and listener.</p>
<p><br />
</p>
<h1><a class="anchor" id="media_queue_usage_talker"></a>
Talker specific flow  </h1>
<p>As a talker, an interface module is responsible for writing data to Media Queue, so important steps are:</p>
<ul>
<li>openavbMediaQHeadLock function for getting the head of the media queue and marking it as locked</li>
<li>openavbMediaQHeadUnlock function which releases head. Any subsequent calls to openavbMediaQHeadLock will return the same MediaQueueItem</li>
<li>openavbMediaQHeadPush function unlocks head previously taken by the Lock function and informs that work on the current Item is finished so that next call to openavbMediaQHeadLock will return next Media Queue Item. Call of this function makes the item accessible via the openavbMediaQTailLock function. This function additionally unlocks the head so the openavbMediaQHeadUnlock call is not needed</li>
</ul>
<p><br />
</p>
<h1><a class="anchor" id="media_queue_usage_listener"></a>
Listener specific flow    </h1>
<p>As a listener, an interface module works on Media Queue tail elements. Data in those items is being written by the mapping module. These are the key Media Queue functions for the listener functionality in an interface module:</p>
<ul>
<li>openavbMediaQTailLock gets an item from the tail and allows working on the current tail item of the Media Queue</li>
<li>openavbMediaQTailUnlock unlocks the tail element in MediaQueue which means that interface module has stopped working on it for now but processing of current tail element will be continued later</li>
<li>openavbMediaQTailPull unlocks the tail element and removes it from the Media Queue. This means that the interface module has finished processing of current tail element and it can be rewritten again by new data. This function additionally unlocks tail, so it is not necessary to call openavbMediaQTailUnlock.</li>
</ul>
<p><br />
</p>
<h1><a class="anchor" id="media_queue_usage_stop"></a>
Stopping     </h1>
<p>During the stopping process following action are taken</p>
<ul>
<li>openavb_intf_cb_t::intf_gen_end_cb is called</li>
<li>openavb_map_cb_t::map_gen_end_cb is called</li>
<li>Media Queue is deleted using the openavbMediaQDelete function which frees the memory taken by all internal structures of Media Queue</li>
</ul>
<p><br />
</p>
<h1><a class="anchor" id="media_queue_usage_rules"></a>
Guidelines    </h1>
<ul>
<li>Calls to <b>Lock</b> functions must always be paired with their <b>Unlock</b> counterparts to avoid problems while working with MediaQueue. Push and Pull functions additional result in an unlock.</li>
<li>The current implementation Media Queue allows accessing two elements at the same time - one is head and second the tail</li>
<li>The number of Media Queue items and their sizes depends on configuration for the stream. The main driving factor is to make the data accessible for the next element that follows interface module. The size of the Media Queue item is a factor of the According to this Media Queue number of size of AVTP stream encapsulation payload multiplied by the packing factor. The number of Media Queue items required if different for a talker and listener. The talker usually needs minimal Media Queue items. However, the listener must have enough Media Queue items to buffer data until the AVTP presentation time. This is based on the maximum transit time for the SR Class in use. ring decoding</li>
<li>If there are not enough Media Queue items warnings will be logged to the implemented logging system for the port for debugging purposes.</li>
</ul>
<p>More implementation details might be find in openavb_mediaq_pub.h </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
